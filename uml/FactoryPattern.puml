@startuml
interface EnemyFactory {
  + createEnemy(int locationX, int locationY, int speedX, int speedY, int hp): EnemyAircraft
}

class EliteFactory implements EnemyFactory {
  + createEnemy(int locationX, int locationY, int speedX, int speedY, int hp): EnemyAircraft
}

class MobFactory implements EnemyFactory {
  + createEnemy(int locationX, int locationY, int speedX, int speedY, int hp): EnemyAircraft
}

abstract class EnemyAircraft {
  + abstract List<BaseBullet> shoot()
}

class EliteEnemy extends EnemyAircraft {
  + shoot(): List<BaseBullet>
}

class MobEnemy extends EnemyAircraft {
  + shoot(): List<BaseBullet>
}

interface PropFactory {
  + createProp(int locationX, int locationY, int speedX, int speedY): AbstractProp
}

class HpPropFactory implements PropFactory {
  + createProp(int locationX, int locationY, int speedX, int speedY): AbstractProp
}

class BulletPropFactory implements PropFactory {
  + createProp(int locationX, int locationY, int speedX, int speedY): AbstractProp
}

class BombPropFactory implements PropFactory {
  + createProp(int locationX, int locationY, int speedX, int speedY): AbstractProp
}

abstract class AbstractProp {
  + abstract void effect(HeroAircraft hero)
}

class HpProp extends AbstractProp {
  + effect(HeroAircraft hero)
}

class BulletProp extends AbstractProp {
  + effect(HeroAircraft hero)
}

class BombProp extends AbstractProp {
  + effect(HeroAircraft hero)
}

class Game {
  - List<AbstractAircraft> enemyAircrafts
  - List<AbstractProp> props
  + action()
}


EliteFactory --> EliteEnemy: creates
MobFactory --> MobEnemy: creates
HpPropFactory --> HpProp: creates
BulletPropFactory --> BulletProp: creates
BombPropFactory --> BombProp: creates


Game --> EnemyFactory: uses
Game --> PropFactory: uses
@enduml